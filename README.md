# 모던 자바 스터디
해당 스터디는 JAVA 11 로 진행됩니다.<br/>
해당 내용에 대한 틀린 부분이나 수정해야할 부분이 있다면 피드백을 남겨주시면 내용 확인 후 검토하여 수정하겠습니다.<br/>
피드백 남겨주시는 분들이 있다면 감사의 말씀을 드립니다.

<hr>

## 동작 파라미터화(Behavior Parameterization)
동작 파라미터화는 어떻게 실행할 것인지 결정하지 않은 코드 블록이다.<br/>
메서드의 인수로 코드 블록을 전달하며 코드 블록의 실행은 나중으로 미뤄 요구사항에 유연하게 대처할 수 있다.

1. 인터페이스와 전략 패턴을 이용하여 동작 파라미터화를 사용해 보자.
2. 익명 클래스를 이용하여 동작 파라미터화를 사용해 보자.
3. 람다 표현식을 사용하여 동작 파라미터화를 사용해 보자.
4. 제네릭을 이용하여 공통 처리기를 만들어 보자.

인터페이스를 이용하여 동작 파라미터화를 구현할 때에는 인터페이스를 구현하는 구현 클래스를 여러개 만들어야 하는 단점이 있다.<br/>
익명 클래스는 구현 클래스를 여러개 안만들어도 되지만 많은 코드 공간을 차지하게 된다.<br/>
**결론** : **람다 표현식**을 사용하여 구현했더니 구현 클래스를 여러개 안만들어도 되고 적은 코드 공간으로 요구사항에 유연하게 대처할 수 있다.<br/>

<hr>

## 람다(Lambda)
람다 표현식은 익명 클래스처럼 이름이 없는 함수면서 메서드를 인수로 깔끔한 코드로 전달 할 수 있다.<br/>
람다 표현식은 함수형 인터페이스라는 문맥에서 사용할 수 있다. 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급할 수 있다.<br/>
함수형 인터페이스는 오직 하나의 추상 메서드만 가지는 인터페이스다.(ex Comparator, Runnable)<br/>
함수형 인터페이스의 추상 메서드 시그니처(signature)는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터(function descriptor)라고 부른다.<br/>

다양한 함수형 인터페이스<br/>
- Predicate\<T> : 제네릭 형식 T 객체를 인수로 받아 불리언을 반환
- Consumer\<T> : 제네릭 형식 T 객체를 인수로 받아 void를 반환
- Function\<T, R> : 제네릭 형식 T 객체를 인수로 받아 제네릭 형식 R 객체를 반환
- UnaryOperator\<T> : 제네릭 형식 T 객체를 인수로 받아 제네릭 형식 T 객체를 반환
- Supplier\<T> : 인수를 받지 않고 제네릭 형식 T 객체를 반환

### 메서드 참조(Method Reference)
메서드 참조는 특정 메서드만을 호출하는 람다의 축약형

<hr>

## 스트림(Stream)
스트림은 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소이다.<br/>
스트림은 데이터 컬렉션 반복을 편리하게 처리해주는 기능이다.<br/>
또한 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.<br/>

- 중간 연산 : 중간 연산은 다른 스트림을 반환한다. 따라서 중간 연산을 연결해서 질의를 만들 수 있다. 스트림 파이프라인에 실행하기 전까지는 아무 연산도 실행하지 않는다. 중간 연산을 합친 다음에 중간 연산을 최종 연산으로 한번에 처리하기 때문이다.(ex - filter, map, limit, sorted, distinct)
- 최종 연산 : 최종 연산은 스트림 파이프라인에서 결과를 도출한다.(ex - forEach, count, collect)

<hr>

참고 서적 : Modern Java in Action(라울-게이브리얼 우르마, 마리오 푸스코, 앨런 마이크로프트 지음)